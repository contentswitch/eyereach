1. Python 的函数参数传递
a = 1
def fun(a):
    a = 2
fun(a)
print a   # 1

a = []
def fun(a):
    a.append(1)
fun(a)
print a # [1]

说明:
string, tuple, 和 number 是不可更改的对象，
而list,dict等则是可以修改的对象

当一个引用传递给函数的时候,函数自动复制一份引用,这个函数里的引用和外边的引用没有半毛关系了.
第一个例子里函数把引用指向了一个不可变对象,当函数返回的时候,外面的引用没半毛感觉.
而第二个例子就不一样了,函数内的引用指向的是可变对象,对它的操作就和定位了指针地址一样,在内存里进行修改

小节:
不可变对象传递为函数参数时候,当函数中修改该对象后,在函数外面访问的时候,对象维持不变
可变对象传递为函数参数时候,当函数中修改该对象后,在函数外面访问的时候,对象被修改

2. Python中的元类(metaclass)
//简介
Python中的一切都是对象，它们要么是类的实例，要么是元类的实例，除了type。type实际上是它自己的元类.
//作用
拦截类的创建
修改类
返回修改之后的类
//主要应用
元类的主要用途是创建API。
一个典型的例子是Django ORM(面向对象映射)
//实例
def make_hook(f):
    """Decorator to turn 'foo' method into '__foo__'"""
    f.is_hook = 1
    return f

class MyType(type):
    def __new__(cls, name, bases, attrs):

        if name.startswith('None'):
            return None

        # Go over attributes and see if they should be renamed.
        newattrs = {}
        for attrname, attrvalue in attrs.iteritems():
            if getattr(attrvalue, 'is_hook', 0):
                newattrs['__%s__' % attrname] = attrvalue
            else:
                newattrs[attrname] = attrvalue

        return super(MyType, cls).__new__(cls, name, bases, newattrs)

    def __init__(self, name, bases, attrs):
        super(MyType, self).__init__(name, bases, attrs)

        # classregistry.register(self, self.interfaces)
        print "Would register class %s now." % self

    def __add__(self, other):
        class AutoClass(self, other):
            pass
        return AutoClass
        # Alternatively, to autogenerate the classname as well as the class:
        # return type(self.__name__ + other.__name__, (self, other), {})

    def unregister(self):
        # classregistry.unregister(self)
        print "Would unregister class %s now." % self

class MyObject:
    __metaclass__ = MyType


class NoneSample(MyObject):
    pass

# Will print "NoneType None"
print type(NoneSample), repr(NoneSample)

class Example(MyObject):
    def __init__(self, value):
        self.value = value
    @make_hook
    def add(self, other):
        return self.__class__(self.value + other.value)

# Will unregister the class
Example.unregister()

inst = Example(10)
# Will fail with an AttributeError
#inst.unregister()

print inst + inst
class Sibling(MyObject):
    pass

ExampleSibling = Example + Sibling
# ExampleSibling is now a subclass of both Example and Sibling (with no
# content of its own) although it will believe it's called 'AutoClass'
print ExampleSibling
print ExampleSibling.__mro__

3. @staticmethod 和@classmethod
def foo(x):
    print "executing foo(%s)" % x

class A(object):
    def foo(self, x):
        print "executing foo(%s, %s)" % (self, x)

    @classmethod
    def class_foo(cls, x):
        print "executing class_foo(%s,%s)" % (cls,x)

    @staticmethod
    def static_foo(x):
        print "executing static_foo(%s)" % x

a = A()

\        实例方法     类方法          静态方法
a = A()  a.foo(x)  a.class_foo(x)  a.static_foo(x)
A        不可用    A.class_foo(x)  A.static_foo(x)

4. class variable vs install variable
在类设计中，经常遇到两种类型的变量：类变量和实例变量。
类变量（class variable）被该类的所有实例可以共享的变量；
如果某个实例修改了该变量，这种变化可以被其他实例看到。
实例变量（object variable, instance variable）属于实例私有；
 对实例变量的操作不会影响到其他实例对象。

举个简单的例子，就很清楚了。
#!/usr/bin/env python

class   Person(object) :
    count_beans = 0

    def __init__(self, name) :
        self.name = name
        self.count_beans = 0

    def pick(self) :
        self.count_beans += 1
        Person.count_beans += 1     #self.__class__.count_beans += 1

        print '%s pick a bean. He picked %d beans, and we all picked %d beans.' % (self.name, self.count_beans, Person.count_beans)

alex = Person('Alex')
alex.pick()

mike = Person('Mike')
mike.pick()
alex.pick()

jack = Person('Jack')
jack.pick()
alex.pick()
mike.pick()

运行结果：
Alex pick a bean. He picked 1 beans, and we all picked 1 beans.
Mike pick a bean. He picked 1 beans, and we all picked 2 beans.
Alex pick a bean. He picked 2 beans, and we all picked 3 beans.
Jack pick a bean. He picked 1 beans, and we all picked 4 beans.
Alex pick a bean. He picked 3 beans, and we all picked 5 beans.
Mike pick a bean. He picked 2 beans, and we all picked 6 beans.

5. Python自省函数getattr(),setattr(),delattr(),hasattr() 
自省: 自省就是面向对象的语言所写的程序在运行时,所能知道对象的类型.
简单一句就是运行时能够获得对象的类型
class A:
    def __init__(self):
        self.name = 'zhangjing'
    def method(self):
        print "method print"
In [20]: a = A()

In [21]: getattr(a, 'name', 'not found')
Out[21]: 'zhangjing'

In [22]: hasattr(a, 'name')
Out[22]: True

In [23]: setattr(a, 'name', 'zhangpeng')

In [24]: hasattr(a, 'name')
Out[24]: True

In [25]: delattr(a, 'name')

In [26]: getattr(a, 'name', 'not found')
Out[26]: 'not found'

In [27]: hasattr(a, 'name')
Out[27]: False
