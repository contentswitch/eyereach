1. Python 的函数参数传递
a = 1
def fun(a):
    a = 2
fun(a)
print a   # 1

a = []
def fun(a):
    a.append(1)
fun(a)
print a # [1]

说明:
string, tuple, 和 number 是不可更改的对象，
而list,dict等则是可以修改的对象

当一个引用传递给函数的时候,函数自动复制一份引用,这个函数里的引用和外边的引用没有半毛关系了.
第一个例子里函数把引用指向了一个不可变对象,当函数返回的时候,外面的引用没半毛感觉.
而第二个例子就不一样了,函数内的引用指向的是可变对象,对它的操作就和定位了指针地址一样,在内存里进行修改

小节:
不可变对象传递为函数参数时候,当函数中修改该对象后,在函数外面访问的时候,对象维持不变
可变对象传递为函数参数时候,当函数中修改该对象后,在函数外面访问的时候,对象被修改

2. Python中的元类(metaclass)
//简介
Python中的一切都是对象，它们要么是类的实例，要么是元类的实例，除了type。type实际上是它自己的元类.
//作用
拦截类的创建
修改类
返回修改之后的类
//主要应用
元类的主要用途是创建API。
一个典型的例子是Django ORM(面向对象映射)
//实例
def make_hook(f):
    """Decorator to turn 'foo' method into '__foo__'"""
    f.is_hook = 1
    return f

class MyType(type):
    def __new__(cls, name, bases, attrs):

        if name.startswith('None'):
            return None

        # Go over attributes and see if they should be renamed.
        newattrs = {}
        for attrname, attrvalue in attrs.iteritems():
            if getattr(attrvalue, 'is_hook', 0):
                newattrs['__%s__' % attrname] = attrvalue
            else:
                newattrs[attrname] = attrvalue

        return super(MyType, cls).__new__(cls, name, bases, newattrs)

    def __init__(self, name, bases, attrs):
        super(MyType, self).__init__(name, bases, attrs)

        # classregistry.register(self, self.interfaces)
        print "Would register class %s now." % self

    def __add__(self, other):
        class AutoClass(self, other):
            pass
        return AutoClass
        # Alternatively, to autogenerate the classname as well as the class:
        # return type(self.__name__ + other.__name__, (self, other), {})

    def unregister(self):
        # classregistry.unregister(self)
        print "Would unregister class %s now." % self

class MyObject:
    __metaclass__ = MyType


class NoneSample(MyObject):
    pass

# Will print "NoneType None"
print type(NoneSample), repr(NoneSample)

class Example(MyObject):
    def __init__(self, value):
        self.value = value
    @make_hook
    def add(self, other):
        return self.__class__(self.value + other.value)

# Will unregister the class
Example.unregister()

inst = Example(10)
# Will fail with an AttributeError
#inst.unregister()

print inst + inst
class Sibling(MyObject):
    pass

ExampleSibling = Example + Sibling
# ExampleSibling is now a subclass of both Example and Sibling (with no
# content of its own) although it will believe it's called 'AutoClass'
print ExampleSibling
print ExampleSibling.__mro__

3. @staticmethod 和@classmethod
def foo(x):
    print "executing foo(%s)" % x

class A(object):
    def foo(self, x):
        print "executing foo(%s, %s)" % (self, x)

    @classmethod
    def class_foo(cls, x):
        print "executing class_foo(%s,%s)" % (cls,x)

    @staticmethod
    def static_foo(x):
        print "executing static_foo(%s)" % x

a = A()

\        实例方法     类方法          静态方法
a = A()  a.foo(x)  a.class_foo(x)  a.static_foo(x)
A        不可用    A.class_foo(x)  A.static_foo(x)

4. class variable vs install variable
在类设计中，经常遇到两种类型的变量：类变量和实例变量。
类变量（class variable）被该类的所有实例可以共享的变量；
如果某个实例修改了该变量，这种变化可以被其他实例看到。
实例变量（object variable, instance variable）属于实例私有；
 对实例变量的操作不会影响到其他实例对象。

举个简单的例子，就很清楚了。
#!/usr/bin/env python

class   Person(object) :
    count_beans = 0

    def __init__(self, name) :
        self.name = name
        self.count_beans = 0

    def pick(self) :
        self.count_beans += 1
        Person.count_beans += 1     #self.__class__.count_beans += 1

        print '%s pick a bean. He picked %d beans, and we all picked %d beans.' % (self.name, self.count_beans, Person.count_beans)

alex = Person('Alex')
alex.pick()

mike = Person('Mike')
mike.pick()
alex.pick()

jack = Person('Jack')
jack.pick()
alex.pick()
mike.pick()

运行结果：
Alex pick a bean. He picked 1 beans, and we all picked 1 beans.
Mike pick a bean. He picked 1 beans, and we all picked 2 beans.
Alex pick a bean. He picked 2 beans, and we all picked 3 beans.
Jack pick a bean. He picked 1 beans, and we all picked 4 beans.
Alex pick a bean. He picked 3 beans, and we all picked 5 beans.
Mike pick a bean. He picked 2 beans, and we all picked 6 beans.

5. Python自省函数getattr(),setattr(),delattr(),hasattr() 
自省: 自省就是面向对象的语言所写的程序在运行时,所能知道对象的类型.
简单一句就是运行时能够获得对象的类型
class A:
    def __init__(self):
        self.name = 'zhangjing'
    def method(self):
        print "method print"
In [20]: a = A()

In [21]: getattr(a, 'name', 'not found')
Out[21]: 'zhangjing'

In [22]: hasattr(a, 'name')
Out[22]: True

In [23]: setattr(a, 'name', 'zhangpeng')

In [24]: hasattr(a, 'name')
Out[24]: True

In [25]: delattr(a, 'name')

In [26]: getattr(a, 'name', 'not found')
Out[26]: 'not found'

In [27]: hasattr(a, 'name')
Out[27]: False

6. 字典推导式
L = [1,2,3,4,5,6,7,8,9]

要生成下面这样的字典：
{1: 10, 2: 20, 3: 30, 4: 40, 5: 50, 6: 60, 7: 70, 8: 80, 9: 90}

以前需要这样：
dict([(v, v*10) for v in L])

现在可以直接这样：(字典推导式)
{v: v*10 for v in L}

附录：
//什么是字典？
字典是Python语言中唯一的映射类型。
映射类型对象里哈希值（键，key）和指向的对象（值，value）是一对多的的关系，通常被认为是可变的哈希表。
字典对象是可变的，它是一个容器类型，能存储任意个数的Python对象，其中也可包括其他容器类型。

字典类型与序列类型的区别：
存取和访问数据的方式不同。
序列类型只用数字类型的键（从序列的开始按数值顺序索引）；
映射类型可以用其他对象类型作键（如：数字、字符串、元祖，一般用字符串作键），和序列类型的键不同，
映射类型的键直接或间接地和存储数据值相关联。
映射类型中的数据是无序排列的。这和序列类型是不一样的，序列类型是以数值序排列的。
映射类型用键直接“映射”到值。

字典是Python中最强大的数据类型之一。

//如何创建字典和给字典赋值
简单地说字典就是用大括号包裹的键值对的集合。（键值对也被称作项）
一般形式：
adict = {}
adict = {key1：value2， key2：value2， …}
或用dict()函数，如，adict = dict() 或 adict = dict（（['x',1],['y',2]））这样写对吗？adict = dict（['x',1],['y',2]）。关键字参数创建字典，如：adict= dict(name=’allen’,age=’40′)
或用fromkeys()方法，如，adict = {}.fromkeys((‘x’,'y’), -1) 这样创建的字典的value是一样的，若不给值，默认为None。
特点：
z1、键与值用冒号“：”分开；
z2、项与项用逗号“，”分开；
z3、字典中的键必须是唯一的，而值可以不唯一。
adict = {‘name’:'allen’, ‘name’:'lucy’, ‘age’:’40′} 与 bdict = {‘name’:'allen’, ‘name2′:’allen’, ‘age’:’40′}
注意：如果字典中的值为数字，最好使用字符串数字形式，如：’age’:’040′ 而不用 ‘age’:040

//字典的基本操作
z1、如何访问字典中的值？
adict[key] 形式返回键key对应的值value，如果key不在字典中会引发一个KeyError。
z2、如何检查key是否在字典中？
a、has_key()方法 形如：adict.haskey(‘name’) 有–>True，无–>False
b、in 、not in   形如：’name’ in adict      有–>True，无–>False
z3、如何更新字典？
a、添加一个数据项（新元素）或键值对
adict[new_key] = value 形式添加一个项
b、更新一个数据项（元素）或键值对
adict[old_key] = new_value
c、删除一个数据项（元素）或键值对
del adict[key] 删除键key的项 / del adict 删除整个字典
adict.pop(key) 删除键key的项并返回key对应的 value值

//映射类型操作符
标准类型操作符（+，-，*，<,>,<=,>=,==,!=,and,or, not)
a、字典不支持拼接和重复操作符（+，*）
b、字典的比较操作
先比较字典的长度也就是字典的元素个数
键比较
值比较
例子：
adict = {}
bdict = {‘name’:'allen’, ‘age’:’40′}
cmp(adict, bdict)  < –>-1 or > –>1 or ==  –>0

//映射相关的函数
z1、len() 返回字典的长度
z2、hash() 返回对象的哈希值，可以用来判断一个对象能否用来作为字典的键
z3、dict() 工厂函数，用来创建字典

//字典的方法
z1、adict.keys() 返回一个包含字典所有KEY的列表；
z2、adict.values() 返回一个包含字典所有value的列表；
z3、adict.items() 返回一个包含所有（键，值）元祖的列表；
z4、adict.clear() 删除字典中的所有项或元素；
z5、adict.copy() 返回一个字典浅拷贝的副本；
z6、adict.fromkeys(seq, val=None) 创建并返回一个新字典，以seq中的元素做该字典的键，val做该字典中所有键对应的初始值（默认为None）；
z7、adict.get(key, default = None) 返回字典中key对应的值，若key不存在字典中，则返回default的值（default默认为None）；
z8、adict.has_key(key) 如果key在字典中，返回True，否则返回False。 现在用 in 、 not in；
z9、adict.iteritems()、adict.iterkeys()、adict.itervalues() 与它们对应的非迭代方法一样，不同的是它们返回一个迭代子，而不是一个列表；
z10、adict.pop(key[,default]) 和get方法相似。如果字典中存在key，删除并返回key对应的vuale；如果key不存在，且没有给出default的值，则引发keyerror异常；
z11、adict.setdefault(key, default=None) 和set()方法相似，但如果字典中不存在Key键，由 adict[key] = default 为它赋值；
z12、adict.update(bdict) 将字典bdict的键值对添加到字典adict中。

//字典的遍历
z1、遍历字典的key（键）
for key in adict.keys():print key
z2、遍历字典的value（值）
for value in adict.values(): print value
z3、遍历字典的项（元素）
for item in adict.items():print item
z4、遍历字典的key-value
for item，value in adict.items(): print ‘key=%s, value=%s’ %(item, value)  或   for item，value in adict.iteritems(): print ‘key=%s, value=%s’ %(item, value)
注意：for item,value in adict.items(): print ‘key=%s’, ‘value=%s’, %(item, value) 这种写法是错误的

//使用字典的注意事项
z1、不能允许一键对应多个值；
z2、键必须是可哈希的。

7. Python 中单下划线和双下划线
__foo__:一种约定,Python 内部的名字,用来区别其他用户自定义的命名,以防冲突. 
_foo:一种约定,用来指定变量私有.程序员用来指定私有变量的一种方式.
__foo:这个有真正的意义:解析器用_classname__foo 来代替这个名字,以区别和其
他类相同的命名.
class MyClass:
    def __init__(self):
        self.__superprivate = "Hello"
        self._semiprivate = ", world!"

In [18]: mc = MyClass()

In [19]: print mc._semiprivate
, world!

In [20]: print mc.__dict__
{'_MyClass__superprivate': 'Hello', '_semiprivate': ', world!'}

In [21]: print mc._MyClass__superprivate
Hello
